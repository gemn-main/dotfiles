В его основе лежит идея разбиения сложной задачи на более простые подзадачи, сохранения результатов этих подзадач и использования их повторно вместо повторных вычислений. 

**то есть это просто рекурсия которая сохраняет ответы чтобы повторно не вычислять**  

но рекурсия не обязательна в ДП. Итеративные методы часто эффективнее по памяти и скорости. Выбор подхода зависит от задачи и ограничений.



условие задачи: даны монеты например `{1, 3, 4}` из них надо составить 1 определённую сумму каждую монету можно использовать бесконечное количество раз 
решение с помощью динамического программирования:
```cpp
int solve (int x)
{
	if (x < 0) return INF;
	if (x == 0) return 0;
	if (ready[x]) return value[x];
	int best = INF;
	for( auto c : coins)
		best = min(best, solve(x-c)+1);
	ready[x] = true;
	value[x] = best;
}
```