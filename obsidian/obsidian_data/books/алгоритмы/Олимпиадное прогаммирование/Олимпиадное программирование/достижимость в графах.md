```cpp
reach[x][x] = 1;
for(auto u : adj[x]){
	reash[x] |= reach[u]
}
```

алгоритм строит матрицу смежности из списка смежности 

1. изначально матрица пуста 
2. в функцию поступает вершина x из нее уже можно попасть в x
3. мы создаем цикл с соседями x 
4. и смотрим куда соседи могут попасть, и если сосед может попасть, то и x может, записываем это в матирицу


---

### **Пошаговый разбор:**

#### **Шаг 0: Изначальная матрица `reach`**
Все элементы `0`, кроме диагонали:
```cpp
reach = [
    [1, 0, 0, 0],  // 0
    [0, 1, 0, 0],  // 1
    [0, 0, 1, 0],  // 2
    [0, 0, 0, 1]   // 3
]
```

#### **Шаг 1: Обрабатываем вершину 2 (у неё нет исходящих рёбер)**
- `adj[2] = {}` (нет соседей).
- Ничего не меняется.  
`reach[2]` остаётся `[0, 0, 1, 0]`.

#### **Шаг 2: Обрабатываем вершину 3 (у неё нет исходящих рёбер)**
- `adj[3] = {}` (нет соседей).
- Ничего не меняется.  
`reach[3]` остаётся `[0, 0, 0, 1]`.

#### **Шаг 3: Обрабатываем вершину 1 (есть ребро 1 → 2)**
- `adj[1] = {2}`.
- Обновляем `reach[1]`:
  ```cpp
  reach[1] |= reach[2];  // Побитовое ИЛИ с [0, 0, 1, 0]
  ```
  - Было: `[0, 1, 0, 0]`
  - Стало: `[0 | 0, 1 | 0, 0 | 1, 0 | 0] = [0, 1, 1, 0]`

Теперь `reach`:
```
reach = [
    [1, 0, 0, 0],  // 0
    [0, 1, 1, 0],  // 1 (обновили!)
    [0, 0, 1, 0],  // 2
    [0, 0, 0, 1]   // 3
]
```

#### **Шаг 4: Обрабатываем вершину 0 (есть рёбра 0 → 1 и 0 → 3)**
- `adj[0] = {1, 3}`.
- Обновляем `reach[0]`:
  1. `reach[0] |= reach[1]` (`[0, 1, 1, 0]`):
     - Было: `[1, 0, 0, 0]`
     - Стало: `[1 | 0, 0 | 1, 0 | 1, 0 | 0] = [1, 1, 1, 0]`
  2. `reach[0] |= reach[3]` (`[0, 0, 0, 1]`):
     - Было: `[1, 1, 1, 0]`
     - Стало: `[1 | 0, 1 | 0, 1 | 0, 0 | 1] = [1, 1, 1, 1]`

Итоговая `reach`:
```
reach = [
    [1, 1, 1, 1],  // 0 → может попасть во все вершины
    [0, 1, 1, 0],  // 1 → может в себя и 2
    [0, 0, 1, 0],  // 2 → может только в себя
    [0, 0, 0, 1]   // 3 → может только в себя
]
```

---

### **Проверка на графе:**
- Из `0` можно попасть:
  - в `1` (прямо),
  - в `2` (через `1`),
  - в `3` (прямо).
- Из `1` можно только в `2`.
- Из `2` и `3` — только в себя.

Всё совпадает с матрицей!

---

