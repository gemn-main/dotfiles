условие: дан массив весов требуется найти все суммы которые можно получить сложение весов
```cpp
int main()
{
    bool possible[16] = {false};
    int w[3] = {3, 5, 7};
    possible[0] = true;
    int m = 16;
    for (int k = 0; k <= 3; k++)
    {
        for (int x = m - w[k]; x >= 0; x--)
        {
            possible[x + w[k]] |= possible[x];
        }
    }
    for (bool x : possible)
        cout << x << ' ';
}
...
1 0 0 1 0 1 0 1 1 0 1 0 1 0 0 1
```
1  0  0  1  0  1  0  1  1  0   1    0    1    0   0    1
0  1  2  3  4  5  6  7  8  9  10  11  12  13 14  15



`w` - это наши веса 
`possible` - это масси индексы которого служат нам числами 1 индекс это число 0,   2 - 1  
`possible[0] = true` - потому что 0 моэно получить всегда 


# Алгорит 

**Берём `w[1] = 3` и обновляем `possible`.**

Идём от `m - w[k] = 15 - 3 = 12` до `0` **назад**:

- `possible[12 + 3] |= possible[12]` (но `possible[12] = false`, ничего не меняется)
- `possible[11 + 3] |= possible[11]` (аналогично)
- `possible[10 + 3] |= possible[10]`
- `possible[9 + 3] |= possible[9]`
- `possible[8 + 3] |= possible[8]`
- `possible[7 + 3] |= possible[7]`
- `possible[6 + 3] |= possible[6]`
- `possible[5 + 3] |= possible[5]`
- `possible[4 + 3] |= possible[4]`
- `possible[3 + 3] |= possible[3]`
- `possible[0 + 3] |= possible[0]` (Тут `possible[0] = true`, значит `possible[3] = true`!)
**Массив после первого прохода:**
`[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`
(только `possible[3] = true`, т.к. мы смогли набрать сумму 3).

## **2-й проход (k = 2, добавляем 5)**

**Берём `w[2] = 5` и обновляем `possible`.**

Идём от `m - w[k] = 15 - 5 = 10` до `0` **назад**:

- `possible[10 + 5] |= possible[10]`
- `possible[9 + 5] |= possible[9]`
- `possible[8 + 5] |= possible[8]`
- `possible[7 + 5] |= possible[7]`
- `possible[6 + 5] |= possible[6]`
- `possible[5 + 5] |= possible[5]`
- `possible[3 + 5] |= possible[3]` (Так как `possible[3] = true`, теперь `possible[8] = true`!)
- `possible[0 + 5] |= possible[0]` (Тут `possible[0] = true`, значит `possible[5] = true`!)

**Массив после второго прохода:**
`[1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]`
Теперь мы можем набрать суммы **3, 5 и 8**.

## **3-й проход (k = 3, добавляем 7)**

**Берём `w[3] = 7` и обновляем `possible`.**

Идём от `m - w[k] = 15 - 7 = 8` до `0` **назад**:

- `possible[8 + 7] |= possible[8]` (Так как `possible[8] = true`, теперь `possible[15] = true`!)
- `possible[5 + 7] |= possible[5]` (Так как `possible[5] = true`, теперь `possible[12] = true`!)
- `possible[3 + 7] |= possible[3]` (Так как `possible[3] = true`, теперь `possible[10] = true`!)
- `possible[0 + 7] |= possible[0]` (Тут `possible[0] = true`, значит `possible[7] = true`!)

**Финальный массив:**
`[1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1]`