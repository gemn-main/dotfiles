```python
class Solution(object):
    def minMaxGame(self, nums):
        def main(nums):
            if len(nums) == 1:
                return nums[0]
            newNums = []
            for i in range(len(nums)//2):
                if i % 2 == 0:
                    newNums.append(min(nums[2 * i], nums[2 * i + 1]))
                else:
                    newNums.append(max(nums[2 * i], nums[2 * i + 1]))

            return main(newNums)
        
        return main(nums)
```

Вам дан целочисленный массив **с индексом 0,**`nums` длина которого равна степени числа `2`.

Примените следующий алгоритм `nums`:

1. Пусть `n`будет длиной `nums`. Если `n == 1`, **завершить** процесс. В противном случае **создать** новый целочисленный массив **с индексом 0**`newNums` длины `n / 2`.
2. Для каждого **четного** индекса , `i`где `0 <= i < n / 2`, **присвоить** значение `newNums[i]`как `min(nums[2 * i], nums[2 * i + 1])`.
3. Для каждого **нечетного** индекса `i`, где `0 <= i < n / 2`, **присвоить** значение `newNums[i]`как `max(nums[2 * i], nums[2 * i + 1])`.
4. **Замените** массив `nums`на `newNums`.
5. **Повторите** весь процесс, начиная с шага 1.

Верните _последнее число, оставшееся_ `nums`_после применения алгоритма._

**Пример 1:**

![](https://assets.leetcode.com/uploads/2022/04/13/example1drawio-1.png)

**Вход:** nums = [1,3,5,2,4,8,2,2]
 **Выход:** 1
 **Пояснение:** Следующие массивы являются результатами многократного применения алгоритма. Первый: nums = [1,5,4,2] Второй: nums = [1,4] Третий: nums = [1] 
1 — последнее оставшееся число, поэтому мы возвращаем 1.

**Пример 2:**

**Ввод:** nums = [3]
 **Вывод:** 3
 **Пояснение:** 3 — это уже последнее оставшееся число, поэтому мы возвращаем 3.