```python
class Solution(object):
    def findRelativeRanks(self, score):
        o = score[:]
        o.sort(reverse=True)
        lowbest = o[3:]
        best = o[:3]
        print(score)
        k = []
        for i in range(len(score)):
            if score[i] in best:
                if best.index(score[i]) == 0:
                    k.append("Gold Medal")
                if best.index(score[i]) == 1:
                    k.append("Silver Medal")
                if best.index(score[i]) == 2:
                    k.append("Bronze Medal")
            else:
                k.append(str(lowbest.index(score[i]) + 4))
        return k
```
Вам дан целочисленный массив scoreразмера n, где score[i]— счет спортсмена на соревновании. Все баллы гарантированно уникальны .ith

Спортсмены занимают места на основе своих очков, где место спортсмена имеет наивысший балл, место спортсмена имеет наивысший балл и т. д. Место каждого спортсмена определяет его рейтинг:1st2nd2nd

Место , которое занимает спортсмен, занимает .1st"Gold Medal"
Место , которое занимает спортсмен, занимает .2nd"Silver Medal"
Место , которое занимает спортсмен, занимает .3rd"Bronze Medal"
Для спортсмена, занявшего первое место, его рангом является номер места (т. е. ранг спортсмена, занявшего первое место, равен ).4thnthxth"x"
Верните массив answerразмером , nгде answer[i]— ранг спортсмена .ith

 

Пример 1:

Ввод: оценка = [5,4,3,2,1]
 Вывод: ["Золотая медаль","Серебряная медаль","Бронзовая медаль","4","5"]
 Пояснение: Места следующие: [1 -е , 2 -е , 3 -е , 4 -е , 5 -е ].
Пример 2:

Ввод: оценка = [10,3,8,9,4]
 Вывод: ["Золотая медаль","5","Бронзовая медаль","Серебряная медаль","4"]
 Пояснение: Места следующие: [1 -е , 5 -е , 3 -е , 2 -е , 4 -е ].
